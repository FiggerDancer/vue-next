/**
 * This module is Node-only.
 * 这个模块禁用Node环境
 */
import {
  NodeTypes,
  ElementNode,
  TransformContext,
  TemplateChildNode,
  SimpleExpressionNode,
  createCallExpression,
  HoistTransform,
  CREATE_STATIC,
  ExpressionNode,
  ElementTypes,
  PlainElementNode,
  JSChildNode,
  TextCallNode,
  ConstantTypes
} from '@vue/compiler-core'
import {
  isVoidTag,
  isString,
  isSymbol,
  isKnownHtmlAttr,
  escapeHtml,
  toDisplayString,
  normalizeClass,
  normalizeStyle,
  stringifyStyle,
  makeMap,
  isKnownSvgAttr
} from '@vue/shared'
import { DOMNamespaces } from '../parserOptions'

/**
 * 字符串化边界
 */
export const enum StringifyThresholds {
  ELEMENT_WITH_BINDING_COUNT = 5,
  NODE_COUNT = 20
}

/**
 * 字符串化的节点
 * 简单元素节点
 * 文本调用节点
 */
type StringifiableNode = PlainElementNode | TextCallNode

/**
 * Regex for replacing placeholders for embedded constant variables
 * (e.g. import URL string constants generated by compiler-sfc)
 * Regex用于替换嵌入常量变量的占位符
 * 例如：引入compiler-sfc产生的URL字符串常量
 */
const expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g

/**
 * Turn eligible hoisted static trees into stringified static nodes, e.g.
 *
 * ```js
 * const _hoisted_1 = createStaticVNode(`<div class="foo">bar</div>`)
 * ```
 *
 * A single static vnode can contain stringified content for **multiple**
 * consecutive nodes (element and plain text), called a "chunk".
 * `@vue/runtime-dom` will create the content via innerHTML in a hidden
 * container element and insert all the nodes in place. The call must also
 * provide the number of nodes contained in the chunk so that during hydration
 * we can know how many nodes the static vnode should adopt.
 *
 * The optimization scans a children list that contains hoisted nodes, and
 * tries to find the largest chunk of consecutive hoisted nodes before running
 * into a non-hoisted node or the end of the list. A chunk is then converted
 * into a single static vnode and replaces the hoisted expression of the first
 * node in the chunk. Other nodes in the chunk are considered "merged" and
 * therefore removed from both the hoist list and the children array.
 *
 * This optimization is only performed in Node.js.
 * 
 * 将符合条件的悬挂静态树变成stringfied静态节点，例如
 *
 * ```js
 * const _hoisted_1 = createStaticVNode(`<div class="foo">bar</div>`)
 * ```
 * 
 * 一个单独的静态虚拟节点可能包含字符串化的内容
 * 用于多个连续的节点（元素和简单的文本），调用一个chunk
 * 
 * `@vue/runtime-dom` 将创建内容通过innerHTML在一个隐藏的容器元素中
 * 并且插入所有的节点在恰当的位置
 * 这个调用必须提供大量的被包含在chunk中的节点
 * 因此在注水的过程中
 * 我们可以知道静态vnode应该采用多少个节点
 * 这个优化扫描一个子节点列表那包含提升的节点，
 * 并且尝试在运行一个未提升的节点前或者在列表的末尾
 * 找到最大的连续提升的节点块
 * 一个块在之后被转化成一个单独的静态虚拟节点
 * 并且在这个块中替换第一个的提升表达式数据块中的节点
 * 其他节点在这个块中被认为是被合并的
 * 并且因此被移除从提升的列表和子节点数组中
 * 
 * 这个优化被执行在Node.js中
 */
export const stringifyStatic: HoistTransform = (children, context, parent) => {
  // bail stringification for slot content
  // 用于插槽内容保释字符串化
  if (context.scopes.vSlot > 0) {
    return
  }

  // 当前节点数
  let nc = 0 // current node count
  // 具有绑定计数的当前元素
  let ec = 0 // current element with binding count
  // 当前的块
  const currentChunk: StringifiableNode[] = []

  /** 
   * 字符串当前块
   * */ 
  const stringifyCurrentChunk = (currentIndex: number): number => {
    // 当前节点数量大于临界值或者具有绑定计数的当前元素大于临界值
    if (
      nc >= StringifyThresholds.NODE_COUNT ||
      ec >= StringifyThresholds.ELEMENT_WITH_BINDING_COUNT
    ) {
      // combine all currently eligible nodes into a single static vnode call
      //  将所有当前符合条件的节点合并到单个静态vnode调用中
      const staticCall = createCallExpression(context.helper(CREATE_STATIC), [
        JSON.stringify(
          currentChunk.map(node => stringifyNode(node, context)).join('')
        ).replace(expReplaceRE, `" + $1 + "`),
        // the 2nd argument indicates the number of DOM nodes this static vnode
        // will insert / hydrate
        // 第二个参数表示这个静态vnode的DOM节点数量将插入或者注水
        String(currentChunk.length)
      ])
      // replace the first node's hoisted expression with the static vnode call
      // 使用静态vnode调用替换第一个节点提升的表达式
      replaceHoist(currentChunk[0], staticCall, context)

      // 当前块的个数大于1
      if (currentChunk.length > 1) {
        for (let i = 1; i < currentChunk.length; i++) {
          // for the merged nodes, set their hoisted expression to null
          // 对于合并的节点，将它们的提升表达式设置为null
          replaceHoist(currentChunk[i], null, context)
        }

        // also remove merged nodes from children
        // 从节点列表中移除被合并的节点
        const deleteCount = currentChunk.length - 1
        children.splice(currentIndex - currentChunk.length + 1, deleteCount)
        return deleteCount
      }
    }
    return 0
  }

  // 
  let i = 0
  for (; i < children.length; i++) {
    // 子节点
    const child = children[i]
    // 获取提升的节点
    const hoisted = getHoistedNode(child)
    if (hoisted) {
      // presence of hoisted means child must be a stringifiable node
      // 悬挂表示子节点必须是可stringiable节点
      const node = child as StringifiableNode
      const result = analyzeNode(node)
      if (result) {
        // node is stringifiable, record state
        // 节点是可字符串化的，记录状态
        nc += result[0]
        ec += result[1]
        currentChunk.push(node)
        continue
      }
    }
    // we only reach here if we ran into a node that is not stringifiable
    // check if currently analyzed nodes meet criteria for stringification.
    // adjust iteration index
    // 我们只有在遇到不可字符串化的节点时才会到达这里
    // 检查当前分析的节点是否满足字符串化的标准。
    // 调整迭代索引
    i -= stringifyCurrentChunk(i)
    // reset state
    // 重置状态
    nc = 0
    ec = 0
    currentChunk.length = 0
  }
  // in case the last node was also stringifiable
  // 以防最后一个节点也是可字符串化的
  stringifyCurrentChunk(i)
}

/**
 * 获取提升的节点
 * @param node 
 * @returns 
 */
const getHoistedNode = (node: TemplateChildNode) =>
  // 节点类型是元素或者是文本调用，存在生成的代码节点，代码节点类型是简单表达式，获取其被提升的节点
  ((node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.ELEMENT) ||
    node.type == NodeTypes.TEXT_CALL) &&
  node.codegenNode &&
  node.codegenNode.type === NodeTypes.SIMPLE_EXPRESSION &&
  node.codegenNode.hoisted

/**
 * data-或者 aria-正则
 */
const dataAriaRE = /^(data|aria)-/
/**
 * 可字符串化的属性
 * @param name 
 * @param ns 
 * @returns 
 */
const isStringifiableAttr = (name: string, ns: DOMNamespaces) => {
  return (
    (ns === DOMNamespaces.HTML
      ? isKnownHtmlAttr(name)
      : ns === DOMNamespaces.SVG
      ? isKnownSvgAttr(name)
      : false) || dataAriaRE.test(name)
  )
}

/**
 * 替换提升的节点
 * @param node 
 * @param replacement 
 * @param context 
 */
const replaceHoist = (
  node: StringifiableNode,
  replacement: JSChildNode | null,
  context: TransformContext
) => {
  const hoistToReplace = (node.codegenNode as SimpleExpressionNode).hoisted!
  context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement
}

/**
 * 不可字符串化的标签
 */
const isNonStringifiable = /*#__PURE__*/ makeMap(
  `caption,thead,tr,th,tbody,td,tfoot,colgroup,col`
)

/**
 * for a hoisted node, analyze it and return:
 * - false: bailed (contains non-stringifiable props or runtime constant)
 * - [nc, ec] where
 *   - nc is the number of nodes inside
 *   - ec is the number of element with bindings inside
 * 对于被提升的节点，分析它并且返回
 *  false 保释  包含非字符串化的属性或者运行时常量
 *  [包含多少节点，具有绑定计数的当前元素数量]
 *  nc 是内部含有的节点数量
 *  ne 是内部有绑定的元素的数量
 */
function analyzeNode(node: StringifiableNode): [number, number] | false {
  // 标签不可字符串化，直接返回
  if (node.type === NodeTypes.ELEMENT && isNonStringifiable(node.tag)) {
    return false
  }

  // 文本调用节点
  if (node.type === NodeTypes.TEXT_CALL) {
    return [1, 0]
  }

  // 自己本身是1
  let nc = 1 // node count 节点数量
  // 自己本身算不算看有无绑定属性
  let ec = node.props.length > 0 ? 1 : 0 // element w/ binding count 内部有绑定的元素数量。
  let bailed = false
  // 保释
  const bail = (): false => {
    bailed = true
    return false
  }

  // TODO: check for cases where using innerHTML will result in different
  // output compared to imperative node insertions.
  // probably only need to check for most common case
  // i.e. non-phrasing-content tags inside `<p>`
  /**
   * 接下来：检查哪些情况下使用innerHTML会与命令式节点插入相比的输出导致不同的结果 
   * 可能只需要检查最常见的情况 
   * 例如:<p> '中的非短语内容标签
   * @param node 
   * @returns 
   */
  function walk(node: ElementNode): boolean {
    for (let i = 0; i < node.props.length; i++) {
      const p = node.props[i]
      // bail on non-attr bindings
      // 保释在非属性绑定上
      if (
        p.type === NodeTypes.ATTRIBUTE &&
        !isStringifiableAttr(p.name, node.ns)
      ) {
        return bail()
      }
      if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind') {
        // bail on non-attr bindings
        // 保释在非属性中绑定
        if (
          p.arg &&
          (p.arg.type === NodeTypes.COMPOUND_EXPRESSION ||
            (p.arg.isStatic && !isStringifiableAttr(p.arg.content, node.ns)))
        ) {
          return bail()
        }
        if (
          p.exp &&
          (p.exp.type === NodeTypes.COMPOUND_EXPRESSION ||
            p.exp.constType < ConstantTypes.CAN_STRINGIFY)
        ) {
          return bail()
        }
      }
    }
    // 遍历子节点
    for (let i = 0; i < node.children.length; i++) {
      // 收集所有节点
      nc++
      const child = node.children[i]
      // 带有绑定属性的元素
      if (child.type === NodeTypes.ELEMENT) {
        if (child.props.length > 0) {
          ec++
        }
        // 递归
        walk(child)
        // 如果中途有保释的直接返回false
        if (bailed) {
          return false
        }
      }
    }
    // 如果中途没有发生过保释，则返回true
    return true
  }

  // 遍历所有节点，收集nc和ec
  return walk(node) ? [nc, ec] : false
}

/**
 * 字符串化节点
 * @param node 
 * @param context 
 * @returns 
 */
function stringifyNode(
  node: string | TemplateChildNode,
  context: TransformContext
): string {
  // 字符串直接返回本身
  if (isString(node)) {
    return node
  }
  // symbol返回 空字符串
  if (isSymbol(node)) {
    return ``
  }
  switch (node.type) {
    case NodeTypes.ELEMENT:
      // 元素 字符串化元素
      return stringifyElement(node, context)
    case NodeTypes.TEXT:
      // 文本  解码文本
      return escapeHtml(node.content)
    case NodeTypes.COMMENT:
      // 注释  解码注释
      return `<!--${escapeHtml(node.content)}-->`
    case NodeTypes.INTERPOLATION:
      // 插值 通过插值转化成字符串，并对该字符串解码
      return escapeHtml(toDisplayString(evaluateConstant(node.content)))
    case NodeTypes.COMPOUND_EXPRESSION:
      // 复杂表达式 通过插值转化成字符串，并对该字符串解码
      return escapeHtml(evaluateConstant(node))
    case NodeTypes.TEXT_CALL:
      // 文本调用 字符串Node
      return stringifyNode(node.content, context)
    default:
      // static trees will not contain if/for nodes
      // 静态树不包含if/for节点
      return ''
  }
}

/**
 * 字符串化元素
 * @param node 
 * @param context 
 * @returns 
 */
function stringifyElement(
  node: ElementNode,
  context: TransformContext
): string {
  // 标签头部
  let res = `<${node.tag}`
  // 遍历，将属性一一添加
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i]
    if (p.type === NodeTypes.ATTRIBUTE) {
      res += ` ${p.name}`
      // value值解码
      if (p.value) {
        res += `="${escapeHtml(p.value.content)}"`
      }
    } else if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind') {
      // 属性名称为bind，且类型为指令
      const exp = p.exp as SimpleExpressionNode
      // 如果表达式开头是_
      if (exp.content[0] === '_') {
        // internally generated string constant references
        // e.g. imported URL strings via compiler-sfc transformAssetUrl plugin
        // 内部生成的字符串常量引用
        // 例如 通过compiler-sfc transformAssetUrl插件导入URL字符串
        res += ` ${(p.arg as SimpleExpressionNode).content}="__VUE_EXP_START__${
          exp.content
        }__VUE_EXP_END__"`
        continue
      }
      // constant v-bind, e.g. :foo="1"
      // 常量v-bind 例如 :foo="1"
      // 获取表达式执行结果
      let evaluated = evaluateConstant(exp)
      // 表达式执行结果不为null或undefined
      if (evaluated != null) {
        // 获取属性的参数
        const arg = p.arg && (p.arg as SimpleExpressionNode).content
        // 属性为class
        if (arg === 'class') {
          // 序列化类名
          evaluated = normalizeClass(evaluated)
        } else if (arg === 'style') {
          // style
          evaluated = stringifyStyle(normalizeStyle(evaluated))
        }
        // 拼接
        res += ` ${(p.arg as SimpleExpressionNode).content}="${escapeHtml(
          evaluated
        )}"`
      }
    }
  }
  // 上下文作用域id v-data1224423
  if (context.scopeId) {
    res += ` ${context.scopeId}`
  }
  // 结尾
  res += `>`
  // 递归书写子节点
  for (let i = 0; i < node.children.length; i++) {
    res += stringifyNode(node.children[i], context)
  }
  // 闭合
  if (!isVoidTag(node.tag)) {
    res += `</${node.tag}>`
  }
  return res
}

// __UNSAFE__
// Reason: eval.
// It's technically safe to eval because only constant expressions are possible
// here, e.g. `{{ 1 }}` or `{{ 'foo' }}`
// in addition, constant exps bail on presence of parens so you can't even
// run JSFuck in here. But we mark it unsafe for security review purposes.
// (see compiler-core/src/transformExpressions)
/**
 * 不安全
 * 原因： eval
 * 从技术上来说evel是安全的
 * 因为仅仅常量表达式可能用在这里
 * 例如 {{1}} {{foo}}
 * 除此之外，常量消耗不依赖于parens的存在，所以你甚至不能在这里运行JSFuck
 * 但出于安全审查的目的，我们将其标记为不安全。
 * (看 compiler-core/src/transformExpressions)
 * @param exp 
 * @returns 
 */
function evaluateConstant(exp: ExpressionNode): string {
  if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
    return new Function(`return ${exp.content}`)()
  } else {
    // compound
    let res = ``
    exp.children.forEach(c => {
      // 表达式子节点遍历
      // 字符串和symbol过滤
      if (isString(c) || isSymbol(c)) {
        return
      }
      // 文本 添加
      if (c.type === NodeTypes.TEXT) {
        res += c.content
      } else if (c.type === NodeTypes.INTERPOLATION) {
        // 插值
        res += toDisplayString(evaluateConstant(c.content))
      } else {
        // 其他
        res += evaluateConstant(c)
      }
    })
    return res
  }
}
