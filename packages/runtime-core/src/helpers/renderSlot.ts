import { Data } from '../component'
import { Slots, RawSlots } from '../componentSlots'
import {
  ContextualRenderFn,
  currentRenderingInstance
} from '../componentRenderContext'
import { Comment, isVNode } from '../vnode'
import {
  VNodeArrayChildren,
  openBlock,
  createBlock,
  Fragment,
  VNode
} from '../vnode'
import { PatchFlags, SlotFlags } from '@vue/shared'
import { warn } from '../warning'
import { createVNode } from '@vue/runtime-core'

/**
 * Compiler runtime helper for rendering `<slot/>`
 * 运行时编译器用于渲染slot
 * @private
 */
export function renderSlot(
  slots: Slots,
  name: string,
  props: Data = {},
  // this is not a user-facing function, so the fallback is always generated by
  // the compiler and guaranteed to be a function returning an array
  // 这不是一个面向用户的函数，
  // 所以fallback总是被编译和守卫生成一个返回值为数组的函数
  fallback?: () => VNodeArrayChildren,
  // 无插槽
  noSlotted?: boolean
): VNode {
  // 如果是web组件，是的话，创造虚拟节点插槽
  if (currentRenderingInstance!.isCE) {
    return createVNode(
      'slot',
      name === 'default' ? null : { name },
      fallback && fallback()
    )
  }

  let slot = slots[name]

  // 该名称的插槽个数大于1警告，并将其转化为返回数组的函数
  if (__DEV__ && slot && slot.length > 1) {
    warn(
      `SSR-optimized slot function detected in a non-SSR-optimized render ` +
        `function. You need to mark this component with $dynamic-slots in the ` +
        `parent template.`
    )
    slot = () => []
  }

  // a compiled slot disables block tracking by default to avoid manual
  // invocation interfering with template-based block tracking, but in
  // `renderSlot` we can be sure that it's template-based so we can force
  // enable it.
  // 已编译槽默认禁用块跟踪，以避免手动 
  // 调用干扰基于模板的块跟踪，但是在 
  // ' renderSlot '我们可以确定它是基于模板的，所以我们可以强制 
  // 启用它。
  if (slot && (slot as ContextualRenderFn)._c) {
    ;(slot as ContextualRenderFn)._d = false
  }
  openBlock()
  // 校验插槽内容 插槽 确保插槽生成的Vnode值有效
  const validSlotContent = slot && ensureValidVNode(slot(props))
  const rendered = createBlock(
    Fragment, // 创建片段
    { key: props.key || `_${name}` }, // 没有key的话，使用插槽名
    validSlotContent || (fallback ? fallback() : []), // 插槽内容
    validSlotContent && (slots as RawSlots)._ === SlotFlags.STABLE
      ? PatchFlags.STABLE_FRAGMENT // 静态片段标记
      : PatchFlags.BAIL // 一个特殊的标志，指示diff算法应该脱离优化模式。
  )
  // 有插槽且有渲染器作用域id
  if (!noSlotted && rendered.scopeId) {
    // 渲染作用域id，收集渲染器作用id
    rendered.slotScopeIds = [rendered.scopeId + '-s']
  }
  // 如果已经编译过了就不再进行跟踪了
  if (slot && (slot as ContextualRenderFn)._c) {
    ;(slot as ContextualRenderFn)._d = true
  }
  return rendered
}

/**
 * 后代节点中至少有一个节点不是虚拟节点或不是注释
 * @param vnodes 
 * @returns 
 */
function ensureValidVNode(vnodes: VNodeArrayChildren) {
  // 后代节点中至少有一个节点不是虚拟节点或不是注释
  return vnodes.some(child => {
    // 子节点不是vnode
    if (!isVNode(child)) return true
    // 子节点是虚拟节点但不是注释
    if (child.type === Comment) return false
    // 子节点是虚拟节点且是Fragment，则需要进行递归判断，
    // 子节点的后代元素至少存在一个不是虚拟节点元素或者是虚拟节点但不是注释
    if (
      child.type === Fragment &&
      !ensureValidVNode(child.children as VNodeArrayChildren)
    )
      return false
    return true
  })
    ? vnodes
    : null
}
