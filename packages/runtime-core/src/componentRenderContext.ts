import { ComponentInternalInstance } from './component'
import { devtoolsComponentUpdated } from './devtools'
import { setBlockTracking } from './vnode'

/**
 * mark the current rendering instance for asset resolution (e.g.
 * resolveComponent, resolveDirective) during render
 * 为资源解析标记这个当前渲染中的实例
 * 例如： resolveComponent resolveDirective 在渲染期间
 */
export let currentRenderingInstance: ComponentInternalInstance | null = null
export let currentScopeId: string | null = null

/**
 * Note: rendering calls maybe nested. The function returns the parent rendering
 * instance if present, which should be restored after the render is done:
 *
 * 注意：渲染中调用可能会存在嵌套
 * 如果存在父组件实例，则当渲染器执行完毕后应该返回该函数父组件实例
 * 
 * ```js
 * const prev = setCurrentRenderingInstance(i)
 * // ...render
 * setCurrentRenderingInstance(prev)
 * ```
 */
export function setCurrentRenderingInstance(
  instance: ComponentInternalInstance | null
): ComponentInternalInstance | null {
  // 之前渲染的实例
  const prev = currentRenderingInstance
  // 设置当前实例
  currentRenderingInstance = instance
  // 当前作用域Id
  currentScopeId = (instance && instance.type.__scopeId) || null
  // v2 pre-compiled components uses _scopeId instead of __scopeId
  // v2 预编译组件使用 _scopeId 代替 __scopedId
  if (__COMPAT__ && !currentScopeId) {
    currentScopeId = (instance && (instance.type as any)._scopeId) || null
  }
  // 返回之前的
  return prev
}

/**
 * Set scope id when creating hoisted vnodes.
 * 当创建被挂起的虚拟节点，设置scopeId
 * @private compiler helper
 */
export function pushScopeId(id: string | null) {
  currentScopeId = id
}

/**
 * Technically we no longer need this after 3.0.8 but we need to keep the same
 * API for backwards compat w/ code generated by compilers.
 * 技术上我们不再需要这个功能在3.0.8版本后，但我们需要保持相同的api用于
 * 向后兼容编译器生成的代码
 * @private
 */
export function popScopeId() {
  currentScopeId = null
}

/**
 * Only for backwards compat
 * 仅仅为了向后兼容
 * @private
 */
export const withScopeId = (_id: string) => withCtx

/**
 * _n 已经序列化
 * _c 已经编译过了
 * _d 禁止跟踪
 * _ns 无作用域
 */
export type ContextualRenderFn = {
  (...args: any[]): any
  _n: boolean /* already normalized 已经序列化 */
  _c: boolean /* compiled 被编译 */
  _d: boolean /* disableTracking */
  _ns: boolean /* nonScoped */
}

/**
 * Wrap a slot function to memoize current rendering instance
 * @private compiler helper
 * 包裹一个插槽函数用于记忆当前渲染中的实例
 * 编译器帮助函数
 */
export function withCtx(
  fn: Function,
  ctx: ComponentInternalInstance | null = currentRenderingInstance,
  isNonScopedSlot?: boolean // __COMPAT__ only 仅用于兼容
) {
  if (!ctx) return fn

  // already normalized
  // 已经初始化
  if ((fn as ContextualRenderFn)._n) {
    return fn
  }

  const renderFnWithContext: ContextualRenderFn = (...args: any[]) => {
    // If a user calls a compiled slot inside a template expression (#1745), it
    // can mess up block tracking, so by default we disable block tracking and
    // force bail out when invoking a compiled slot (indicated by the ._d flag).
    // This isn't necessary if rendering a compiled `<slot>`, so we flip the
    // ._d flag off when invoking the wrapped fn inside `renderSlot`.
    // 如果一个用户调用一个编译后的插槽在一个模板表达式中，它可能会破坏块追踪
    // 所以默认我们禁止块追踪并且强制放弃当调用一个编译后的插槽时
    // 使用_d 标记表示
    // 如果渲染一个被编译后的<slot>这是不必要的，所以我们关闭_d标记当调用
    // renderSlot中的包装函数
    if (renderFnWithContext._d) {
      setBlockTracking(-1)
    }
    // 设置渲染中的实例，并返回上一个实例
    const prevInstance = setCurrentRenderingInstance(ctx)
    // 执行函数
    const res = fn(...args)
    // 设置回去
    setCurrentRenderingInstance(prevInstance)
    if (renderFnWithContext._d) {
      setBlockTracking(1)
    }

    // 开发者工具组件更新
    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {
      devtoolsComponentUpdated(ctx)
    }

    return res
  }

  // mark normalized to avoid duplicated wrapping
  // 标记序列化标记避免重复包装
  renderFnWithContext._n = true
  // mark this as compiled by default
  // this is used in vnode.ts -> normalizeChildren() to set the slot
  // rendering flag.
  // 标记着默认被编译
  // 这被用于vnode.ts中 序列化子节点用于设置插槽渲染标记
  renderFnWithContext._c = true
  // disable block tracking by default
  // 禁止默认块追踪
  renderFnWithContext._d = true
  // compat build only flag to distinguish scoped slots from non-scoped ones
  // 兼容性构建仅仅标记用于区分作用域插槽和非作用域插槽
  if (__COMPAT__ && isNonScopedSlot) {
    renderFnWithContext._ns = true
  }
  return renderFnWithContext
}
